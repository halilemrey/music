<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Halil Emre - Music Profile</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Poppins', sans-serif;
            background-color: #0c0a18;
            background-image: url('https://w.wallha.com/ws/13/g9ndE8o5.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }

        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .card-wrapper {
            position: absolute;
            will-change: transform, opacity;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            transition: transform 1.2s cubic-bezier(0.2, 1, 0.4, 1),
                        opacity 0.8s ease-out;
        }

        .card-wrapper::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transform: skewX(-25deg);
            transition: left 0.75s;
            z-index: 10;
        }

        .card-wrapper:hover::before {
            left: 150%;
        }

        @media (min-width: 769px) {
            .card-wrapper:hover {
                box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
                z-index: 15;
            }
        }

        .spotify-icon {
            transition: transform 0.3s, filter 0.3s;
            cursor: pointer;
        }

        .spotify-icon:hover {
            transform: scale(1.1);
            filter: brightness(1.3);
        }

        .content-safe-zone {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 400px;
            max-width: 90%;
            transform: translate(-50%, -50%);
            z-index: 5;
            text-align: center;
            padding: 2.5rem;
            background: rgba(25, 20, 20, 0.75);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            animation: fadeInUp 1s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translate(-50%, calc(-50% + 20px));
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        .logo-container {
            opacity: 0;
            animation: fadeIn 1.2s ease-out 1.5s forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .content-safe-zone * {
            pointer-events: auto;
        }

        .footer-disclaimer {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
            text-align: center;
            width: 90%;
            z-index: 10;
        }

        @media (max-width: 768px) {
            .content-safe-zone {
                width: 90%;
                padding: 1.5rem;
            }
            .content-safe-zone h1 {
                font-size: 2.5rem;
            }
            .content-safe-zone p {
                font-size: 1rem;
            }
            .content-safe-zone .spotify-icon {
                width: 5rem;
            }
            .footer-disclaimer {
                font-size: 0.6rem;
            }
        }
    </style>
</head>

<body class="text-white">

    <canvas id="particle-canvas"></canvas>

    <div class="footer-disclaimer">
        <a href="https://www.instagram.com/halil_emrey/" target="_blank" class="inline-block opacity-70 hover:opacity-100 transition-opacity mb-2">
            <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/600px-Instagram_icon.png" alt="Instagram" class="w-5 h-5" />
        </a>
        <div>
            Bu site kiÅŸisel ve ticari olmayan bir projedir. TÃ¼m albÃ¼m kapaklarÄ± ve marka logolarÄ±, ilgili sahiplerinin mÃ¼lkiyetindedir.
        </div>
    </div>

    <div class="content-safe-zone">
        <h1 class="text-5xl font-bold mb-4">
            Halil Emre
        </h1>
        <p class="text-lg mb-6 text-gray-300">
            Welcome to my music space. Cards will find you here ðŸŽ¶
        </p>
        <div class="flex gap-6 justify-center logo-container">
            <a href="https://open.spotify.com/user/slhwdejaps98mgy3ldr2fpqks?si=03f3dba54b9a48aa" target="_blank">
                <img src="https://cdn-icons-png.flaticon.com/512/174/174872.png" alt="Spotify" class="w-28 spotify-icon" />
            </a>
        </div>
    </div>

    <div id="card-container" class="absolute top-0 left-0 w-full h-full z-0"></div>

    <script>
        //---- DEÄžÄ°ÅžKEN TANIMLAMALARI ----//
        let cardWidth;
        let cardHeight;
        let maxConcurrentCards;
        let particleCount;
        let cardScale = 1.0;
        const CARD_LIFETIME = 5000;

        const allCards = [
            { embedSrc: "https://open.spotify.com/embed/track/07q0QVgO56EorrSGHC48y3?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/6si71supnBUhddjR2FJc2L?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/album/0mHYRe0jUP2pWxrL7oP5qO?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/3tCcO0uqXnoB8NnFuMPoIS?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/68xnudIZzP49DreYAMlbqZ?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/1wMvP4KuZOcA3kum0TE6x6?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/4lwfABJjnJYPIgLjuGiB63?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/3hRV0jL3vUpRrcy398teAU?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/6EMErc5L7mnqJ5JsWFYRgX?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/52v12pqh8SBzZ6OSi8ciUL?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/6uS2G7PdDL0qmYs6glOgrO?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/31AOj9sFz2gM0O3hMARRBx?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/4Xvs1baIxOaEwplbKGu9uW?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/41ltDUT9gjqZMWuiDeB6Og?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/1FAERur0SW0KB38aii9tPF?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/5gNchicUY2EvUvZOE2eBzg?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/5Cdt8J09LxpqmhKmOZ0fZr?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/5RaBP5ZEKsjhU0EOhvfunB?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/3FJIkYZLcZMXi7h7z509en?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/779w7valkzLVzFiTC0wHkp?utm_source=generator" },
            { embedSrc: "https://open.spotify.com/embed/track/32f4hFMwHkw3Ooeqf0hbnK?utm_source=generator" }
        ];

        const cardContainer = document.getElementById('card-container');
        const safeZoneEl = document.querySelector('.content-safe-zone');
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        let safeZoneRect;
        let activeCardPositions = [];
        let particlesArray = [];
        let shuffledPlaylist = [];
        let shuffledRotations = [];
        const starColors = ['#FFFFFF', '#E0E0E0', '#B0B0B0', '#ADD8E6'];
        let mouse = {
            x: window.innerWidth / 2,
            y: window.innerHeight / 2
        };

        class Particle {
            constructor(x, y, dx, dy, radius, color, opacity, depth) {
                this.x = x;
                this.y = y;
                this.originX = x;
                this.originY = y;
                this.directionX = dx;
                this.directionY = dy;
                this.radius = radius;
                this.baseRadius = radius;
                this.color = color;
                this.opacity = opacity;
                this.depth = depth;
                this.pulseSpeed = Math.random() * 0.04 + 0.01;
                this.angle = Math.random() * Math.PI * 2;
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.hexToRgb(this.color)}, ${this.opacity})`;
                ctx.fill();
                ctx.closePath();
            }

            update() {
                this.x = this.originX - (mouse.x - window.innerWidth / 2) * this.depth;
                this.y = this.originY - (mouse.y - window.innerHeight / 2) * this.depth;
                this.originX += this.directionX;
                this.originY += this.directionY;

                if (this.originX > canvas.width + this.radius) {
                    this.originX = -this.radius;
                }
                if (this.originX < -this.radius) {
                    this.originX = canvas.width + this.radius;
                }
                if (this.originY > canvas.height + this.radius) {
                    this.originY = -this.radius;
                }
                if (this.originY < -this.radius) {
                    this.originY = canvas.height + this.radius;
                }
                
                this.angle += this.pulseSpeed;
                this.radius = this.baseRadius + Math.sin(this.angle) * (this.baseRadius * 0.2);
            }

            hexToRgb(hex) {
                let r = 0, g = 0, b = 0;
                if (hex.length == 7) {
                    r = parseInt(hex.substring(1, 3), 16);
                    g = parseInt(hex.substring(3, 5), 16);
                    b = parseInt(hex.substring(5, 7), 16);
                }
                return `${r},${g},${b}`;
            }
        }

        class ShootingStar {
            constructor() {
                this.reset();
            }

            reset() {
                this.len = Math.random() * 80 + 10;
                this.speed = Math.random() * 4 + 4;
                this.opacity = 0.7 + Math.random() * 0.3;
                this.angle = (Math.PI / 6) + (Math.random() * Math.PI / 6);
                
                if (Math.random() > 0.5) {
                    this.x = Math.random() * canvas.width;
                    this.y = 0;
                } else {
                    this.x = 0;
                    this.y = Math.random() * canvas.height;
                }
            }

            update() {
                this.x += this.speed * Math.cos(this.angle);
                this.y += this.speed * Math.sin(this.angle);
                this.opacity -= 0.01;

                if (this.x > canvas.width || this.y > canvas.height || this.opacity <= 0) {
                    this.reset();
                }
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.len * Math.cos(this.angle), this.y - this.len * Math.sin(this.angle));
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function setDynamicVariables() {
            if (window.innerWidth <= 768) {
                cardWidth = 150;
                cardHeight = 96;
                maxConcurrentCards = 4;
                particleCount = 115;
                cardScale = 0.9;
            } else {
                cardWidth = 300;
                cardHeight = 152;
                maxConcurrentCards = 5;
                particleCount = 200;
                cardScale = 1.0;
            }
        }

        function initParticles() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            particlesArray = [];
            
            const layers = [
                { count: Math.floor(particleCount * 0.25), radius: 0.5, speed: 0.1, opacity: 0.4, depth: 0.01 },
                { count: Math.floor(particleCount * 0.50), radius: 1.0, speed: 0.2, opacity: 0.7, depth: 0.02 },
                { count: Math.floor(particleCount * 0.25), radius: 1.5, speed: 0.3, opacity: 1.0, depth: 0.04 }
            ];

            layers.forEach(layer => {
                for (let i = 0; i < layer.count; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const dx = (Math.random() - 0.5) * layer.speed;
                    const dy = (Math.random() - 0.5) * layer.speed;
                    const radius = Math.random() * layer.radius + 0.5;
                    const color = starColors[Math.floor(Math.random() * starColors.length)];
                    particlesArray.push(new Particle(x, y, dx, dy, radius, color, layer.opacity, layer.depth));
                }
            });

            const numberOfShootingStars = 2;
            for (let i = 0; i < numberOfShootingStars; i++) {
                particlesArray.push(new ShootingStar());
            }
        }

        function updateSafeZone() {
            safeZoneRect = safeZoneEl.getBoundingClientRect();
        }

        function rectsOverlap(r1, r2) {
            return !(r1.right < r2.left || r1.left > r2.right || r1.bottom < r2.top || r1.top > r2.bottom);
        }

        function generateNewRotations() {
            const baseRotations = [-35, -28, -21, -14, -7, 7, 14, 21, 28, 35];
            const variedRotations = baseRotations.map(angle => angle + (Math.random() * 4 - 2));
            shuffledRotations = shuffleArray(variedRotations);
        }

        function getSafeRandomPosition() {
            let x, y, isSafe, boundingBox;
            let attempts = 0;
            const maxAttempts = 200;
            const cardMargin = 15;
            
            if (shuffledRotations.length === 0) {
                generateNewRotations();
            }
            const rotation = shuffledRotations.pop();

            const rotationRad = rotation * Math.PI / 180;
            const w = cardWidth * cardScale;
            const h = cardHeight * cardScale;
            const rotatedWidth = Math.abs(w * Math.cos(rotationRad)) + Math.abs(h * Math.sin(rotationRad));
            const rotatedHeight = Math.abs(w * Math.sin(rotationRad)) + Math.abs(h * Math.cos(rotationRad));
            
            do {
                const randomX = Math.random() * (window.innerWidth - rotatedWidth);
                const randomY = Math.random() * (window.innerHeight - rotatedHeight);
                x = randomX + (rotatedWidth - w) / 2;
                y = randomY + (rotatedHeight - h) / 2;
                boundingBox = {
                    left: randomX,
                    top: randomY,
                    right: randomX + rotatedWidth,
                    bottom: randomY + rotatedHeight
                };
                const collisionBox = {
                    left: boundingBox.left - cardMargin,
                    top: boundingBox.top - cardMargin,
                    right: boundingBox.right + cardMargin,
                    bottom: boundingBox.bottom + cardMargin
                };
                isSafe = !rectsOverlap(collisionBox, safeZoneRect);
                if (isSafe) {
                    for (const existingRect of activeCardPositions) {
                        if (rectsOverlap(collisionBox, existingRect)) {
                            isSafe = false;
                            break;
                        }
                    }
                }
                attempts++;
            } while (!isSafe && attempts < maxAttempts);

            if (!isSafe) {
                console.warn(`Could not find a safe position for a new card after ${maxAttempts} attempts.`);
                return null;
            }
            return { x, y, rotation, boundingBox };
        }

        function createStaticCard(data) {
            if (!data) {
                return;
            }
            
            const positionData = getSafeRandomPosition();
            if (!positionData) {
                return;
            }

            const { x, y, rotation, boundingBox } = positionData;
            activeCardPositions.push(boundingBox);

            const wrapper = document.createElement('div');
            wrapper.className = 'card-wrapper';
            wrapper.style.width = `${cardWidth}px`;
            wrapper.style.height = `${cardHeight}px`;
            
            const startX = window.innerWidth / 2 - (cardWidth / 2);
            const startY = window.innerHeight / 2 - (cardHeight / 2);
            const randomStartRotation = (Math.random() - 0.5) * 30;

            wrapper.style.zIndex = '1'; 
            wrapper.style.opacity = '0';
            wrapper.style.transform = `translate3d(${startX}px, ${startY}px, 0) scale(0.5) rotate(${randomStartRotation}deg)`;

            const clippingDiv = document.createElement('div');
            clippingDiv.style.cssText = 'width: 100%; height: 100%; border-radius: 12px; overflow: hidden; position: relative; z-index: 1;';
            
            const iframe = document.createElement('iframe');
            iframe.style.cssText = 'width: 100%; height: 100%; border: none;';
            iframe.src = data.embedSrc;
            iframe.allow = "autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture";
            iframe.loading = "lazy";

            clippingDiv.appendChild(iframe);
            wrapper.appendChild(clippingDiv);
            cardContainer.appendChild(wrapper);

            setTimeout(() => {
                wrapper.style.zIndex = '2';
                wrapper.style.opacity = '1';
                wrapper.style.transform = `translate3d(${x}px, ${y}px, 0) scale(${cardScale}) rotate(${rotation}deg)`;
            }, 100);

            setTimeout(() => {
                wrapper.style.opacity = '0';
                wrapper.style.transform = `translate3d(${x}px, ${y}px, 0) scale(${cardScale + 0.12}) rotate(${rotation}deg)`;
            }, CARD_LIFETIME);

            setTimeout(() => {
                const cardIndex = activeCardPositions.indexOf(boundingBox);
                if (cardIndex > -1) {
                    activeCardPositions.splice(cardIndex, 1);
                }
                if (wrapper.parentNode) {
                    wrapper.parentNode.removeChild(wrapper);
                }
            }, CARD_LIFETIME + 1000);
        }

        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function getNextCard() {
            if (shuffledPlaylist.length === 0) {
                shuffledPlaylist = shuffleArray([...allCards]);
            }
            return shuffledPlaylist.pop();
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            setDynamicVariables();
            updateSafeZone();
            initParticles();
        }

        function masterAnimate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            particlesArray.forEach(p => {
                p.update();
                p.draw();
            });
            requestAnimationFrame(masterAnimate);
        }

        function tryToCreateCard() {
            if (activeCardPositions.length < maxConcurrentCards) {
                const nextCard = getNextCard();
                createStaticCard(nextCard);
            }
        }

        //--- BaÅŸlangÄ±Ã§ FonksiyonlarÄ± ---//
        setDynamicVariables();
        updateSafeZone();
        initParticles();
        generateNewRotations();
        masterAnimate();
        setTimeout(tryToCreateCard, 1000);
        setInterval(tryToCreateCard, 1500);

        //--- Event Listeners ---//
        window.addEventListener('resize', debounce(handleResize, 250));
        window.addEventListener('mousemove', e => {
            mouse.x = e.x;
            mouse.y = e.y;
        });
    </script>
</body>

</html>
